

# C_Study

        
------        
        
### 作者：冰红茶  
### 参考书籍：《C Primer Plus》
            
------    
            
        

   其实说到当初为什么要学C语言，因为想学计算机底层的东西，然后想到了操作系统，想到了linux。而linux又是用C语言写的，所以自然而言的就想去学C语言了^_ ^
  
## 目录

## [一、C语言介绍](#1)
### [1.1 简介](#1.1)
### [1.2 HelloWorld 与 system函数](#1.2)   
### [1.3 gcc翻译的过程](#1.3)
## [二、  算法](#2)
### [2.1 基本概念](#2.1)
## [三、  数据结构](#3)
### [3.1 编程规范](#3.1)
### [3.2 关键字标识符数据类型](#3.2)
### [3.3 变量的存储类别](#3.3)
### [3.4 类型转换](#3.4)
### [3.5 输入输出屏幕与打印格式](#3.5)
### [3.6 运算符与表达式](#3.6)
## [四、  条件选择与循环控制](#4)
### [4.1 条件选择](#4.1)
### [4.2 循环控制](#4.2)
### [4.3 goto语句](#4.3)
### [4.4 随机数函数](#4.4)
## [五、  数组](#5)
### [5.1 数组的声明和定义](#5.1)
### [5.2 选择法排序](#5.2)
### [5.3 交换法排序](#5.3)
### [5.4 冒泡法排序](#5.4)
### [5.5 插入法排序](#5.5)
### [5.6 归并法排序](#5.6)
### [5.7 快速法排序](#5.7)
        
------      
        
<h2 id='1'>一、、C语言介绍</h2>
<h3 id='1.1'>1.1 简介</h3>  
        
#### 1) 历史
> - C语言是在1972年贝尔实验室的丹尼斯·里奇（Dennis Ritch）和肯·汤普森（Ken Thompson）在开发UNIX操作系统时基于B语言设计的
> - 目前流行的C语言有：Microsoft C或称MS C；Borland Turbo C或称Turbo C；AT&T C
#### 2) 语言特点
> - 机器语言  低级语言，也称为“二进制代码语言”用0和1组成，特点是计算机可以直接识别，不需要任何的翻译。
> - 汇编语言
> - 高级语言
> - C语言同时具备汇编语言和高级语言的优点，不同于C++，他是一种面向过程的语言，包括windows, linux在内很多的操作系统都是用C语言写的。
#### 3) 优点
> - 高效性，具备只有汇编语言才有的微调控制能力，可以根据情况微调程序以获得最大的运行速度和最有效的使用内存；
> - 可移植性：许多计算机系统都可以使用C编译器，把C代码转换成计算机内部指令的程序；
> - 强大灵活：UNIX操作系统大部分使用C编写的，FORTRAN, Perl, Pascal, Python, Logo, BASIC等许多编译器和解释器都是用C语言编写的，即这些语言最后都是有C程序生成最后的可执行程序；
#### 4) C语言标准
> - 第一个标准是美国国家标准协会ANSI于1989年公布，称为C89，该版本后被国际标准化组织ISO接收并批准，所有又可以称为C90。由于是ANSI先公布的标准，所以业内人士一般使用ANSI C。
> - C99标准，1994年
> - C11标准，2011年
> - 使用gcc命令时，可以添加参数以使用不同的标准，如：
                
                gcc -std=c99 inform.c
                gcc -std=c1x inform.c
                gcc -std=c11 inform.c

        
<h3 id='1.2'>1.2 HelloWorld 与 system函数</h3>
        
#### 1) 代码
> - 先用vim生成一个文件名.c的文件，然后在里面写 
                
                #include <stdio.h>

                int main(){
                    printf("Hello World!");
                    return 0;
                }
#### 2) C语言程序编写的特点
> - 头文件中包含了main函数的声明，所以可以直接使用main函数，不需要额外的人为声明；
> - C语言由函数组成，有且只有一个主函数main；
> - 程序运行从main开始，main函数由系统自动调用，不需要人为调用；
> - return 0，程序结束；
> - 常用的IDE有：Turbo C 2.0，Visual C++ 6.0
> - 字符编码：linux默认是utf-8, windows默认是ANSI
#### 3）注意事项 
> - 然后使用命令：gcc 文件名.c  \[-o\] 编译文件名
> - 如果不加\[-o\] 编译文件名，则会生成默认的编译文件名a.out
> - 接着执行该文件，如果当前目录是文件的目录，则需要加“./”
> - C语言的源代码文件是一个普通的文件，但是其拓展名必须是.c 函数由函数头和函数体组成;
#### 4）gcc
> -  Gun Compiler Collection，GNU编译器套件
> - -o file 制定生成的文件名为file；
> - 在linux下编译的程序只能在linux下运行，不能在windows下运行
#### 5）在window平台
> - 在windows下也可以使用gcc命令，前提是你把gcc的目录添加到环境变量中去，还要把include文件和lib文件的目录添加进去，重新打开cmd，输入PATH，看是否存在以上三个路径，若存在，恭喜你可以使用gcc的命令，亲测有效^< ^
> - Windows 切换路径也可以使用cd，切换盘符可以直接使用英文字母加冒号的方法，比如d:
> - cls是清空命令的意思；
> - calc 计算器
> - mspaint 画图板
> - notepad 记事本       
#### 6) system函数
> - int system(const char *command);        //在已经运行的程序外部执行另外一个程序。 
> - 用该函数时需要头文件#include< stdlib.h>，在linux平台里面，gcc编译器中几乎所有的头文件都在/usr目录下面。
                
                #include<stdio.h>
                #include<stdlib.h>

                int main(){

                        printf("Before print\n");
                        system("ls");   //查看的是可执行程序.out所在的目录
                        printf("After print\n");
                        return 0;
                }
        
<h3 id='1.3'>1.3 gcc翻译的过程</h3>
        
#### 1) 4个过程
> - 预处理，宏定义展开，头文件展开，条件编译等，同时将代码中的注释删除，这里并不会检查语法，gcc -E hello.c -o hello.i
> - 汇编：检查语法，将预处理后的文件编译生成汇编文件，gcc -S hello.i -o hello.s；
> - 编译：将编译文件生成目标文件（二进制文件），gcc -c hello.s -o hello.o； 即将源代码转换为机器语言代码，并把结果放在目标代码文件中，此为目标文件，在windows系统中一般是.obj文件
> - 链接：C语言写的程序需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去
#### 2) 细节
> - 在库中包含有很多类似于printf()函数的的指令，称为库文件；
> - 启动代码（startup code），充当着程序和操作系统之间的接口，Windows和Linux所需要的启动代码不同。
> - 链接中的链接器就是将目标代码，系统标准启动代码和库代码三部分合并成一个文件，即可执行文件，在windows系统中一般是.exe文件，在linux中系统中一般是.out文件
> - ldd 可执行文件：查看可执行文件需要哪些动态库，在macOS下是otool -L；
                
                [lvhongbin@MiWiFi-R3G-srv cStudy]$ ldd 02_systemfunctiontest.out
                linux-vdso.so.1 =>  (0x00007ffc3d977000)
                libc.so.6 => /lib64/libc.so.6 (0x00007fa05bb2d000)
                /lib64/ld-linux-x86-64.so.2 (0x000055676fdec000)

                // macOS
                LvHongbins-Mac-2:HelloWorld lvhongbin$ otool -L ./HelloWorld.out
                ./HelloWorld.out:
                    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.50.4)
#### 3) 命令
> - -E 只进行预处理；
> - gcc -S 只进行预处理和编译；
> - gcc -c 只进行预处理，编译和汇编
> - gcc -o file 指定生成的输出文件名为file
        
------      
        
<h2 id='2'>二、  算法</h2>
<h3 id='2.1'>2.1 基本概念</h3>  
        
> - 一个程序是由算法，数据结构，程序设计方法以及语言工具和环境这四个方面组成，其中，算法是核心。
> - 算法是由算法设计和算法分析组成，算法设计就是针对特定问题的解决办法，算法分析即分析算法步骤的正确性和复杂性
#### 1) 算法的特性
> - 有穷性
> - 确定性
> - 可行性
> - 输入
> - 输出
#### 2) 衡量算法的优劣指标
> - 正确性
> - 可读性
> - 健壮性
> - 时间复杂度和空间的复杂度
        
------      
        
<h2 id='3'>三、 数据结构</h2>
<h3 id='3.1'>3.1 编程规范</h3>  
        
#### 1) 代码缩进
#### 2) 变量常量命名规范
> - 常量名统一为大写格式，如果是普通变量，要以数据类型的小写字母开头，然后取实际意义的首字母大写的名称，如果是成员变量，还要加上m_的开头。指针的话前面要以p开头
#### 3) 函数命名规范
> - 驼峰式命名，首字母大写。
> - 变量命名使用名词性词组，函数命名使用动词性词组
#### 4) 注释
        
<h3 id='3.2'>3.2 关键字标识符数据类型</h3>  
        
#### 1) C语言一共有32个关键字
> -  数据类型关键字12个 short int long float double char unsigned signed struct union enum void 
> -  控制语句关键字12个：if else switch while goto return default break do for continue case
> -  存储类关键字5个 auto static register extern const
> -  其他关键字3个：sizeof（获取定义该数据类型需要分配多大的空间） 
                
                typeof volatile
                printf("Print  sizeof(char)=%u\n",sizeof(char));
#### 2) 数据类型
> - 基本类型（short, int, long, char, float, double）
>> - 整形
>>> - 短整型short，一般占2个字节，16位
>>> - 基本整形int，一般占4个字节，32位，具体跟计算机的字节数有关,包括符号整形（取值范围为-32768~+32767）和无符号整形（后面加U or l，取值范围为0~65535）
>>> - 长整形long32位（后面加L or l）
>> - 字符型char，一般占1个字节，8位，用单直撇括起的一个字符，不能是字符串
>> - 实型
>>> - 单精度型float，一般占4个字节，32位，7位有效数字
>>> - 双精度型double，一般占8个字节，64位，15-16位有效数字
> - 构造类型
>> - 数组类型
>> - 结构体类型strut
>> - 共同体类型union
>> - 枚举类型enum
> - 指针类型
>> - 32位的编译器下所有类型的指针变量，char*也好，int*也好，double*也好，都占4个字节；
>> - 64位的编译器下所有类型的指针变量，char*也好，int*也好，double*也好，都占8个字节；
> - 空类型void
#### 3) 进制
> - 八进制 前面添加0，0后数字0~7，不能出现超过7的数字
> - 十进制
> - 十六进制 前面添加0x，0x后数字0~9，字母a~f/A~F
                
                printf("Print  [8] 17=%o\n",17);    //八进制打印
                printf("Print  [10] 17=%d\n",17);   //十进制打印
                printf("Print  [16] 17=%x\n",17);   //十六进制打印，字母以小写输出；
                printf("Print  [16] 17=%X\n",17);   //十六进制打印，字母以大写输出；
                
                结果：Print  [8] 17=21
                Print  [10] 17=17
                Print  [16] 17=11
#### 4) 原码反码与补码
> - 正数的原码反码和补码相同
> - 为什么不用原码进行储存？
>> - 0有两种存储方式，符号位一个为0，一个为1；
>> - 正数和负数相加，结果不正确（计算机只会加不会减）
符号位：最高位；
#### 5) 反码
> - 正数的原码和反码是一样的；
> - 求原码；
> - 其他位取反（0为1，1为0；
> - 为什么不用反码进行储存？ 0有两种存储方式，符号位一个为0，一个为1
#### 6) 补码
> - 正数的补码是他的原码，负数的补码是他绝对值的二进制形式按位取反后再加1，最高位为符号位，0代表正数，1代表负数。相同绝对值的正数和负数想加，最高位1丢弃，结果为0000 0000，此时0只有一种存储方式；
> - 如果你想从补码得知它的源码的话，最开始的方式是先减1，然后求反码。由于正数和负数是可逆的，所以你可以重复求补码的操作，也就是说两次原码求补码的操作得到的是源码；
#### 7) 实型常量
> - 实型常量后面可以用F/f或者L/l来修饰，其中F/f表示单精度类型，L/l表示双精度类型;
#### 8) 字符常量vs字符串常量
> - 字符常量只能是一个字符，用单引号作为分界符，字符串可以有多个字符，用双引号作为分界符，末尾系统自动添加\0，作为字符串的结束标志，这也就是“H”的长度为2的原因。
#### 9) 转义字符\
> - \n换行回车
> - \r光标位置回到句首
> - \t制表位
> - \a鸣铃
#### 10) 字符型变量
> - 实际上是以无符号整形的ASCII码值储存在内存单元中，使用命令man ascii可以查看ACSII表，小写字母比大写字母大32，小写转大写，小写字母-32；a是97，A是65
#### 11) 无符号unsigned vs有符号signed的区别
> - 无符号最高位不是符号位，而算作为数的一部分
> - 无符号输出用%u
#### 12) 数值越界
                
                char a=127+2
> - 如果是有符号输出，则129转换为二进制码1000 0001，站在计算机的角度，这是补码
                
                补码：1000 0001
                反码：1111 1110
                原码：1111 1111 最高位是符号位，得-127
> - 如果是无符号输出，参数入栈时，不足int的，扩展为int后入栈
比如char(129)也即char(-127)扩展成int(-127)。也就是由 10000001 扩展成 11111111 11111111 11111111 10000001。然后你使用%u，也就是将 11111111 11111111 11111111 10000001 当成 unsigned int 来看，那它当然就是 4294967169 了
换句话说，要维持值不变，在高位补1还是补0取决于原来的符号位，这称为符号扩展（Sign Extension）。”
#### 13) sizeof运算符
> - 对于直接的调用sizeof，如果是数组首地址，sizeof会输出数组所占地址空间的大小（字节为单位)。如果是一个指针的话，则输出在该系统中地址的字节宽度，即（位宽/8)。
> -  如果是通过函数传递过来的地址，那么sizeof会把数组首地址和指针无差别当成是地址。
> -  所有的指针和地址均占4字节
        
<h3 id='3.3'>3.3 变量的存储类别</h3>  
        
#### 1) auto关键字
> - 用于定义一个局部变量，意味着每次执行到定义该变量时，都会产生一个新的变量，并且对 其重新初始化；
                
                auto int iInt = 1;
> - 事实上，auto可以省略不写，因为局部变量的默认存储方式为自动的；
#### 2) static关键字
> - 静态变量
#### 3) register变量
> - 寄存器存储变量，对于一个具备可移植性的程序来说，register的作用并不大，不过不同于放在内存中，放在寄存器中效率更高，但是由于寄存器数量不多；
#### 4) extern变量
> - 外部存储变量，相当于public，在另外的c文件中可以调用本c文件中的变量
####5)  volatile变量
> - 防止编译器优化代码，比如跑马灯的时候
                
                int a;
                a=1;
                a=2;
                a=3;
                a=4;
> - 跑马灯轮流亮，但是站在编译器的角度，最终结果是a=4，所以a=1~3的步骤会被编译器优化删除，此时跑马灯就跑不起来了，所以为例避免编译器作多余的优化，要加上此关键词。
        
<h3 id='3.4'>3.4 类型转换</h3>  
        
#### 1) auto关键字
> - 自动类型转换
> - 强制类型转换 
                
                int j = (int)i;

        
<h3 id='3.5'>3.5 输入输出屏幕与打印格式</h3>  
        
> - C语言对字符和字符串的区别非常严格，所以对于单引号和双引号的使用也是非常清晰
#### 1) 输出：putchar() 输出字符；
> - 不仅可以输出普通的字符，也可以输出转义字符，如putchar(‘\101’)等同于putchar(‘A’)，需要添加#include< stdio.h>
#### 2) 输入：getchar() 输入字符；
> - 要注意的是如果输出包含有换行\n，getchar会自动获取该换行符号
#### 3) 输出：puts()，输出字符串，但是不能进行格式化操作；
#### 4) 输入：gets()，输入字符串，但是不能进行格式化操作；
#### 5) 输出：printf，输出字符串；
#### 6) 输入：scanf(格式控制, 地址列表)；
> - 阻塞，等待用户输入内容，按回车结束，输入不需要加换行的符号\n
> - 编写程序时，在scanf函数的地址列表处，一定要使用变量的地址 &标识符，而不是变量的标识符，否则会报错。
#### 7) 格式化
**格式化符号** | **含义**
-|-
%hd | 输入/输出short类型；
%d | 输入/输出int类型 可以使用%5d为输出，表示一共5个字符，默认是右对齐；%-5d中减号默认为右对齐；
%l | 输入/输出long类型
%ll | 输入/输出long long类型(8位)
%hu | 输入/输出unsigned short类型
%u | 输入/输出unsigned类型
%lu | 输入/输出unsigned long类型
%llu | 输入/输出unsigned long long类型
%c | 输入/输出字符类型
%s | 输入/输出字符串类型
%p | 输入/输出指针以16进制的形式
%% | 输入/输出一个%

        
<h3 id='3.6'>3.6 运算符与表达式</h3>  
        
#### 1) 算术运算符
> - + - * / % ++ -- 
> - 两个数相除，如果商想要获得小数，分子和分母必须是一个小数，否则结果只会取整；
#### 2)  赋值运算符
> - =  +=  -=  *=  /=  %=
#### 3)  比较运算符
> - ==  !=  <  >  <=  >=
#### 4)  逻辑运算符
> - &&  ||  ！
> - 短路规则 ||，左边为真，右边不执行；&&，左边为假，右边不执行；
> - 优先级比赋值运算符要高；
#### 5)  位运算符
> - &:按位操作符(“与”) 将两个表达式的值按二进制位展开，对应的位（bit）按值进行”与”运算，结果保留在该位上。
> - 按位或运算符(|)
>> - 按位或运算的典型用法是将一个位串信息的某几位置成1。如将要获得最右4为1，其他位与变量j的其他位相同，可用逻辑或运算017|j。若要把这结果赋给变量j，可写成：
                
                j = 017|j 
> - 按位异或运算符(^)
>> - 异或运算的意思是求两个运算分量相应位值是否相异，相异的为1，相同的为0。按位异或运算的典型用法是求一个位串信息的某几位信息的反。如欲求整型变量j的最右4位信息的反，用逻辑异或运算017^j，就能求得j最右4位的信息的反,即原来为1的位，结果是0,原来为0的位，结果是1。
> - 按位取反运算符(~)
>> -  ~7的结果为0xfff8 
#### 6) 移位运算
> - 移位运算用来将整型或字符型数据作为二进位信息串作整体移动。有两个运算符
                
                << (左移) 和 >> (右移)
> - 移位运算是双目运算，有两个运算分量,左分量为移位数据对象，右分量的值为移位位数。移位运算将左运算分量视作由二进位组成的位串信息,对其作向左或向右移位，得到新的位串信息
> - 左移时，空出的右端用0补充，左端移出的位的信息就被丢弃。在二进制数运算中，在信息没有因移动而丢失的情况下，每左移1位相当于乘2。如4 << 2，结果为16
> - 右移运算将一个位串信息向右移指定的位，右端移出的位的信息被丢弃。例如12>>2,结果为3。与左移相反，对于小整数，每右移1位，相当于除以2。在右移时，需要注意符号位问题。对无符号数据，右移时，左端空出的位用0补充。对于带符号的数据，如果移位前符号位为0(正数)，则左端也是用0补充；如果移位前符号位为1(负数)，则左端用0或用1补充，取决于计算机系统。对于负数右移，称用0 补充的系统为“逻辑右移”，用1补充的系统为“算术右移”。
#### 7) sizeof运算符
> - 返回的是一个无符号整数类型，实际上该返回类型为size_t，它使用了typedef来定义
                
                typedef unsigned int size_t;
#### 8) 运算符优先级
> - 优先级1（从左往右）：【】数组下标 （） 圆括号 .成员变量 ->成员选择
> - 优先级2（从右往左）：单目运算符 -  ~ ++  --  *  &取地址  ！ （类型）强制类型转换  sizeof长度运算符
#### 9) 自增和自减要慎用，不要自作聪明
> - 在同一个表达式或者函数的参数中，对某一个变量执行自加或者自减的操作，很容易出现模凌两可的情况，这是因为编译器的执行顺序的不明确导致的，试看：
                
                Int num=5;
                Int a= num+num*num++;
                // 有可能出现a=5+5*5=30，也有可能出现a=6+6*5=36的结果
> - 为了避免这种情况的出现，应该遵循以下两个原则:
>> - 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或者递减运算符；
>> - 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或者递减运算符；
> - 原因：
>> - 副作用（side effect）：对数据对象或者文件的修改；
>> - 序列点（squence point）：程序执行的点，在该点上，所有的副作用都在进入下一步之前完成，分号是一个序列点，一个完整的表达式也是一个序列点，赋值运算符，递增运算符和递减运算符的副作用必须在一个序列点之前完成，这就说明了在同一个表达式中多次出现的同一个参数，C编译器只能保证在序列点之前完成相应次数的递增或者递减，但是没办法保证他在子表达式后立即执行，这就是不要自作聪明的原因；
        
------      
        
<h2 id='4'>四、 条件选择与循环控制</h2>
<h3 id='4.1'>4.1 条件选择</h3>  
        
#### 1) If
#### 2) 三目运算符
#### 3) switch
> - switch语句检验的表达式必须是一个整形表达式，意味着可以使用函数调用和运算符；case检验的值必须是整形常量；但是其效率没有if高，所以当检验的条件较少，如3~4个的时候建议用if，否则用switch
                
                switch(表达式){
                    case 情况1:
                        语句块1;
                    case 情况2:
                        语句块2;
                    case 情况3:
                        语句块3;
                    default:
                        语句块4;
                }

        
<h3 id='4.2'>4.2 循环控制</h3>  
        
#### 1)  while(表达式)语句
#### 2)  do…while
#### 3)  for(循环变量赋初值;循环条件;循环变量){}
> - 若省略“循环变量赋初值”，则必须在循环体之前添加初值，且其后的分号不能省略；
> - 若省略“循环条件”，则默认表达式2始终为真，则循环会无终止地进行下去；
> - 若省略“循环变量”，则程序员应该设法保证程序能结束；
> - 若三个都省略，for（；；），那就相当于while(1){循环体语句}程序将无休止地进行下去
                
                // 打印ASCII表
                printf("Table ASCII\n");
                    char cChar;
                    for(cChar=65; cChar<91; cChar++){
                            printf("%c%c\t", cChar, cChar+32);
                            if(4 == cChar % 6){
                                    printf("\n");
                            }
                    }
                    printf("\n");

                // 注意：
                // 使用gcc编译代码是报出
                // error: 'for' loop initial declarations are only allowed in C99 mode
                note: use option -std=c99 or -std=gnu99 to compile your code
                错误，这是因为在gcc中直接在for循环中初始化了增量：
                    for(int i=0; i<len; i++) {  
                    }  
                    这语法在gcc中是错误的，必须先先定义i变量：
                    int i;  
                    for(i=0;i<len;i++){  
                      
                    }  
                // 这是因为gcc基于c89标准，换成C99标准就可以在for循环内定义i变量了：
                gcc src.c -std=c99 -o src
#### 4) 区别 
> - for语句功能更强，凡是用while循环能完成的功能，用for循环都能实现；
> - while和do while，循环变量的初始化需要在循环前完成；
> - c语言的break语句只能跳出离它最近的一层循环，continue语句结束本次循环；
        
<h3 id='4.3'>4.3 goto语句</h3>  
        
#### 1) 模板
> - 
                
                goto 标识符；
                标识符：
> - 容易出现的错误是错误4：label at end of compound statement（标志出现在复合语句的末尾）GCC4不允许行标记之后为空，加上空语句";"就可以了，如
                
                goto here;
                
                改成：
                here:  ;

        
<h3 id='4.4'>4.4 随机数函数</h3>  
        
#### 1) 简介
> - 在C语言中，生成一个随机数，一般利用两个函数，即void srand ( unsigned int seed ) 和 int rand ( void )。
> - srand() 函数用于生成一个随机数种子，种子的值等于参数seed，这个参数由我们指定一个数、式子或者函数值。而 rand() 函数根据这个随机数种子进行运算生成一个\[ 0 , RAND_MAX (int或 unsigned int最大值) \]范围内的随机数。
> - 在一个程序中只需运行一次srand函数即可，若参数seed是一个固定值，则同一程序中多次调用rand函数生成的数是随机数，但多次调用这一程序时，由于初始的随机数种子相同，所以生成的随机数列完全相同，因此一般使用系统时间函数time(NULL)（在time.h文件中，返回从1970年1月1日0点到现在的秒数的值）作为参数seed，使每次调用程序时的种子或者随机数列也具有一定的随机性。
> - 例如给int x 赋值为 [ 0 , 100 ) 的随机整数，先调用 srand(time(NULL))，再利用表达式x = rand()%100 即可。
#### 2) 不够随机的问题
> -如果在一个程序在中，循环调用 srand(time(NULL)) 和 rand() 函数，由于现在计算机运行快速，两次循环的时间差不到1秒，使每次的随机数种子相同，从而生成的随机数也相同。即使在循环中加延时函数，由于时差不大，生成的随机数也相差不大，而且使程序运行时间大大增加。因此，一定要在循环外使用srand函数，一个程序中使用一次即可。
> 如果对随机性要求较高，要避免采用取模操作%，这是为了避免在某些情况下，某些伪随机数生成器产生的数，低位不够随机的问题，此时应采用 x = (int) (100.0 * rand() / (RAND_MAX + 1.0)) ，生成一个 [ 0 , 100 ) 的随机浮点数，再将其转换为 int 型，从而得到一个 0 ~ 99 的随机整数。
        
------      
        
<h2 id='5'>五、 数组</h2>
<h3 id='5.1'>5.1 数组的声明和定义</h3>  
        
#### 1) 模板
> - 类型说明符 数组标识符\[常量表达式\]
                
                // 如：
                int array[5];
> - 其实也有字符串常量的数组定义：
                
                // 如：
                char cChar[6]={“hello”};
> - 至于为什么是6而不是5，是因为字符串“hello”中隐含了一个字符“\0”，这是系统自己自动加的，所以需要特别注意。
> - 数组使用前一定要初始化，要不然会有很多奇怪的事情发生
> - 字符‘\0’跟数字0等价
> - 典型的错误
                
                Char a[]={‘a’,’b’};
                Printf(“%s\n”,a);   //乱码，没有结束符’\0’;

                正确的做法1
                Char a[10]={‘a’,’b’};   //初始化时自动补零
                Printf(“%s\n”,a);       //正确

                正确的做法2
                Char a[]={‘a’,’b’,0};   //有零
                Printf(“%s\n”,a);       //正确

                正确的做法3
                Char a[]={‘a’,’b’,’\0’};    //有零
                Printf(“%s\n”,a);       //正确

        
<h3 id='5.2'>5.2 选择法排序</h3>  
        
#### 1) 介绍
> - 先选择第一个数为目标值，然后从后面的数中挑选出最大（小）值，然后跟前一个数（这里先是第一个数）比较，如果挑选出的数更大（小），就进行交换；接着对第二个数为目标值，如此类推，直至完全排序。
                
                /* ***************************************************************
                 *      Filename: 03_SortSelect.c
                 *   Description:
                 *       Version: 1.0
                 *       Created: 2017/01/12 
                 *      Revision: none
                 *      Compiler: gcc
                 *        Author: Lv Hongbin
                 *       Company: Shanghai JiaoTong Univerity
                 * **************************************************************/

                #include<stdio.h>
                #include<stdlib.h>

                int main(){

                        printf("\n/* ***************************************\n");
                        printf("Select Sort\n");
                        int N=0;
                        printf("Please input N(N<1000) numbers to sort\nN=");
                        scanf("%d",&N);
                        char cDirection;
                        printf("Please select the direction\na:large->small;\tb:small->large;\nDirection=");
                        getchar();
                        cDirection=getchar();
                        int i=0,j=0,b=0,k=0;
                        int a[1000];
                        for (i=0;i<N;i++){
                                printf("No.%d:",i);
                                scanf("%d",&a[i]);
                        }
                        for(j=0;j<N;j++){
                                b=0;
                                k=j;
                                for(i=j+1;i<N;i++){
                                        if(b<a[i]){
                                                b=a[i];
                                                k=i;
                                        }
                                }
                                if(a[j]<b){
                                        b=a[j];
                                        a[j]=a[k];
                                        a[k]=b;
                                }
                        }
                        if(cDirection=='a'){
                                printf("\nSort from large one to samll one: \n");
                                for(i=0;i<N;i++){
                                        printf("%d\t",a[i]);
                                }
                "03_SortSelect.c" 60L, 1282C

        
<h3 id='5.3'>5.3 交换法排序</h3>  
        
#### 1) 介绍
> - 以第一个数为目标数，然后比较剩余的数，遇到最大（小）数就进行交换，然后以第二个数为目标数，如此类推；
                
                /* ***************************************************************
                 *      Filename: 03_SortSwap.c
                 *   Description:
                 *       Version: 1.0
                 *       Created: 2017/01/12 
                 *      Revision: none
                 *      Compiler: gcc
                 *        Author: Lv Hongbin
                 *       Company: Shanghai JiaoTong Univerity
                 * **************************************************************/

                #include<stdio.h>
                #include<stdlib.h>

                int main(){

                        printf("\n/* ***************************************\n");
                        printf("Select Sort\n");
                        int N=0;
                        printf("Please input N(N<1000) numbers to sort\nN=");
                        scanf("%d",&N);
                        char cDirection;
                        printf("Please select the direction\na:large->small;\tb:small->large;\nDirection=");
                        getchar();
                        cDirection=getchar();
                        int i=0,j=0,b=0,k=0;
                        int a[1000];
                        for (i=0;i<N;i++){
                                printf("No.%d:",i);
                                scanf("%d",&a[i]);
                        }
                        for(j=0;j<N;j++){
                                for(i=j+1;i<N;i++){
                                        if(a[j]<a[i]){
                                                b=a[i];
                                                a[i]=a[j];
                                                a[j]=b;
                                        }
                                }
                        }
                        if(cDirection=='a'){
                                printf("\nSort from large one to samll one: \n");
                                for(i=0;i<N;i++){
                                        printf("%d\t",a[i]);
                                }
                        }else{
                                printf("\nSort from samll one to large one: \n");
                                for(i=0;i<N;i++){
                                        printf("%d\t",a[N-i-1]);
                                }
                        }
                "03_SortSwap.c" 54L, 1233C

        
<h3 id='5.4'>5.4 冒泡法排序</h3>  
        
#### 1) 介绍
> - 这个很出名，就不说了
                
                /* ***************************************************************
                 *      Filename: 03_SortBubble.c
                 *   Description:
                 *       Version: 1.0
                 *       Created: 2017/01/11 
                 *      Revision: none
                 *      Compiler: gcc
                 *        Author: Lv Hongbin
                 *       Company: Shanghai JiaoTong Univerity
                 * **************************************************************/

                #include<stdio.h>
                #include<stdlib.h>

                int main(){

                        printf("\n/* ***************************************\n");
                        printf("Bubble Sort\n");
                        int N=0;
                        printf("Please input N(N<1000) numbers to sort\nN=");
                        scanf("%d",&N);
                        char cDirection;
                        printf("Please select the direction\na:large->small;\tb:small->large;\nDirection=");
                        getchar();
                        cDirection=getchar();
                        int i=0,j=0,b=0;
                        int a[1000];
                        for (i=0;i<N;i++){
                                printf("No.%d:",i);
                                scanf("%d",&a[i]);
                        }
                        if(cDirection=='a'){
                                printf("\nSort from large one to samll one: \n");
                                for(j=0;j<N;j++){
                                        for(i=0;i<N-1-j;i++){
                                                if(a[i]>a[i+1]){
                                                        b=a[i+1];
                                                        a[i+1]=a[i];
                                                        a[i]=b;
                                                }
                                        }
                                        printf("%d\t",a[N-1-j]);
                                }
                        }else{
                                printf("\nSort from samll one to large one: \n");
                                for(j=0;j<N;j++){
                                        for(i=0;i<N-1-j;i++){
                                                if(a[i]<a[i+1]){
                                                        b=a[i+1];
                                                        a[i+1]=a[i];
                                                        a[i]=b;
                "03_SortBubble.c" 59L, 1333C

        
<h3 id='5.5'>5.5 插入法排序</h3>  
        
#### 1) 介绍
> - 关键把插入的数做好备份，然后简单的做法是写三个循环，其中有一个循环是用来做插入式的序号调整
                
                /* ***************************************************************
                 *      Filename: 03_SortInsert.c
                 *   Description:
                 *       Version: 1.0
                 *       Created: 2017/01/11 
                 *      Revision: none
                 *      Compiler: gcc
                 *        Author: Lv Hongbin
                 *       Company: Shanghai JiaoTong Univerity
                 * **************************************************************/

                #include<stdio.h>
                #include<stdlib.h>

                int main(){

                        printf("\n/* ***************************************\n");
                        printf("Insert Sort\n");
                        int N=0;
                        printf("Please input N(N<1000) numbers to sort\nN=");
                        scanf("%d",&N);
                        char cDirection;
                        printf("Please select the direction\na:large->small;\tb:small->large;\nDirection=");
                        getchar();
                        cDirection=getchar();
                        int i=0,j=0,k=0,tem=0;
                        int a[1000];
                        for (i=0;i<N;i++){
                                printf("No.%d:",i);
                                scanf("%d",&a[i]);
                        }
                        for(j=1;j<N;j++){
                                tem = a[j];
                                for(i=0;i<j;i++){
                                        if(a[i]<tem){
                                                for(k=j;k>i;k--){
                                                        a[k]=a[k-1];
                                                }
                                                a[i]=tem;
                                                break;
                                        }
                                }
                        }
                        if(cDirection=='a'){
                                printf("\nSort from large one to samll one: \n");
                                for(i=0;i<N;i++){
                                        printf("%d\t",a[i]);
                                }
                        }else{
                                printf("\nSort from samll one to large one: \n");
                                for(i=0;i<N;i++){
                "03_SortInsert.c" 57L, 1280C  

        
<h3 id='5.6'>5.6 分治法排序</h3>  
        
#### 1) 介绍
> - 总体思路
                
                int DivideStrategy(char *a, int left, int right){
                    if(left==right){
                        return …
                    }else{
                        int middle=(left+ right)/2;
                        left= DivideStrategy(a, left, middle);
                        right= DivideStrategy(a, middle+1, right);
                        //其他操作；
                        return …
                    }
                }
> - 有一个缺点，如果采用原址排序的话，需要在合并的时候采用二阶循环，如果不采用原址排序的话，需要开辟多一倍的空间
                
                /* ***************************************************************
                 *      Filename: DividedSort.c
                 *   Description:
                 *       Version: 1.0
                 *       Created: 2018/06/24 
                 *      Revision: none
                 *      Compiler: gcc
                 *        Author: Lv Hongbin
                 *       Company: Shanghai JiaoTong Univerity
                 * **************************************************************/

                #include<stdio.h>
                #include<time.h>
                #include<sys/time.h>
                #include <stdlib.h>

                void SelectSort1(int array[], int n);
                void SelectSort2(int array[], int n);
                void BubbleSort(int array[], int n);
                void merge(int array[], int leftStart, int leftEnd, int rightEnd);
                void DividedSort(int array[], int start, int end);
                void Merge(int *a, int p, int q, int r );

                int main()
                {
                    int array[] = { 1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8};
                    int i;
                    struct timeval StartTime, EndTime;
                    double cost;
                    gettimeofday(&StartTime,NULL);
                    DividedSort(array, 0, 899);
                    for(i=0; i<900; i++) {
                        printf("%d\t",array[i]);
                        if(i%10 == 9) {
                            printf("\n");
                        }
                    }
                    gettimeofday(&EndTime,NULL);
                    cost=(EndTime.tv_sec-StartTime.tv_sec)*1000000+(EndTime.tv_usec-StartTime.tv_usec);
                    printf("\n采用分治排序法 The time cost is %.f\n",cost);
                    return 0;
                }

                // 分治法
                void DividedSort(int arrays[],int start, int end) {
                    if(start < end) {
                        int leftStart=start;
                        int leftEnd=(start + end)/2;
                        int rightStart=(start + end)/2 + 1;
                        int rightEnd=end;
                        // 左侧
                        DividedSort(arrays, leftStart, leftEnd);

                        // 右侧
                        DividedSort(arrays, rightStart, rightEnd);

                        // 合并
                        Merge(arrays, leftStart, leftEnd, end);
                    }
                }

                // 数组合并-空间复杂度为O(1);
                void merge(int array[], int leftStart, int leftEnd, int rightEnd) {
                    int i=leftEnd, j=leftEnd, temp=0;

                    // printf("\n合并前\n");
                    // for(i=leftStart; i<=rightEnd; i++) {
                    //  printf("%d\t",array[i]);
                    // }
                    // printf("\n");
                    for(i=leftEnd; i<rightEnd; i++) {
                        if(array[i] < array[i+1]) {
                            break;
                        }
                        for(j=i; j>=leftStart; j--) {
                            if(array[j] > array[j+1]) {
                                temp = array[j];
                                array[j] = array[j+1];
                                array[j+1] = temp;
                            }
                        }
                    }
                    // printf("\n合并后\n");
                    // for(i=leftStart; i<=rightEnd; i++) {
                    //  printf("%d\t",array[i]);
                    // }
                    // printf("\n");

                }

                // 数组合并-空间复杂度为O(1);
                void Merge(int array[], int leftStart, int leftEnd, int rightEnd){

                        int i=0, j=0, temp=0;

                        // printf("\n合并前\n");
                        // for(i=leftStart; i<=rightEnd; i++) {
                        //  printf("%d\t",array[i]);
                        // }
                        // printf("\n");

                        int p = leftStart;
                        int q = leftEnd+1;
                        int n = rightEnd-leftStart+1;
                        int *b=malloc(n * sizeof(int));
                        for (i = 0; i < n; i++)
                        {
                            if (p > leftEnd) {
                                b[i] = array[q];
                                q++;
                            }else if (q > rightEnd){
                                b[i] = array[p];
                                p++;
                            }else{
                                if(array[p] < array[q]) {
                                    b[i] = array[p];
                                    p++;
                                }else {
                                    b[i] = array[q];
                                    q++;
                                }
                            }
                        }
                        for (j=0; j < n; j++) {
                            array[leftStart+j] = b[j];
                        }
                        free(b);

                        // printf("\n合并后\n");
                        // for(i=leftStart; i<=rightEnd; i++) {
                        //  printf("%d\t",array[i]);
                        // }
                        // printf("\n");
                }

        
<h3 id='5.7'>5.7 快速排序法</h3>  
        
#### 1) 介绍
> - 总体思路:
>> - 分解：将一个数组分为三部分，首先以最后一个元素为基准，比它大的放在右边，比它小的放在左边，然后将最后一个元素放在中间，采取原址排序的方法，最后返回基准元素的下标
>> - 解决：通过递归调用快速排序，分别为array\[p...q-1\] array\[p...q+1\]，至于为什么没有array\[q\]元素，原因在于原址排序它的位置就是正确的位置，所以不需要动
>> - 合并：由于是原址排序，所以没有必要合并
                
                /* ***************************************************************
                 *      Filename: QuickSort.c
                 *   Description:
                 *       Version: 1.0
                 *       Created: 2018/06/24 
                 *      Revision: none
                 *      Compiler: gcc
                 *        Author: Lv Hongbin
                 *       Company: Shanghai JiaoTong Univerity
                 * **************************************************************/

                #include<stdio.h>
                #include<time.h>
                #include<sys/time.h>
                #include <stdlib.h>

                int Divide(int array[], int Start, int end);
                void DividedSort(int array[],int start, int end);

                int main()
                {
                    int array[] = { 1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,1,3,5,7,9,2,4,6,8,
                                    1,3,5,7,9,2,4,6,8};
                    int i;
                    struct timeval StartTime, EndTime;
                    double cost;
                    gettimeofday(&StartTime,NULL);
                    
                    DividedSort(array,0 ,899);
                    for(i=0; i<900; i++) {
                        printf("%d\t",array[i]);
                        if(i%10 == 9) {
                            printf("\n");
                        }
                    }
                    gettimeofday(&EndTime,NULL);
                    cost=(EndTime.tv_sec-StartTime.tv_sec)*1000000+(EndTime.tv_usec-StartTime.tv_usec);
                    printf("\n采用快速排序法 The time cost is %.f\n",cost);
                    return 0;
                }



                // 分治法
                void DividedSort(int array[],int start, int end) {
                    if(start < end) {
                        // 分解
                        int DividePoint = Divide(array, start, end);

                        int leftStart=start;
                        int leftEnd=DividePoint-1;
                        int rightStart=DividePoint + 1;
                        int rightEnd=end;
                        // 左侧
                        DividedSort(array, leftStart, leftEnd);

                        // 右侧
                        DividedSort(array, rightStart, rightEnd);
                    }
                }


                // Divide function
                // 以最后一个元素为基准进行原址排序
                int Divide(int array[], int start, int end) {

                    int DividePoint = start-1;
                    int i = start;
                    int tem = 0;

                    // printf("\n合并前\n");
                    // for(i=start; i<=end; i++) {
                    //  printf("%d\t",array[i]);
                    // }
                    // printf("\n");

                    for(i = start; i<end; i++) {
                        if (array[i] < array[end]) {
                            DividePoint++;
                            tem = array[i];
                            array[i] = array[DividePoint];
                            array[DividePoint] = tem;
                        }
                    }
                    DividePoint++;
                    tem = array[end];
                    array[end] = array[DividePoint];
                    array[DividePoint] = tem;

                    // printf("\n合并后\n");
                    // for(i=start; i<=end; i++) {
                    //  printf("%d\t",array[i]);
                    // }
                    // printf("\n");
                    // printf("DividePoint = %d\n", DividePoint);
                    return DividePoint;
                }